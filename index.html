<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Zhaoyd&#39;s Notes">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Zhaoyd&#39;s Notes">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhaoyd">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Zhaoyd's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zhaoyd's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/01/31/server-shutdown/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaoyd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhaoyd's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/31/server-shutdown/" class="post-title-link" itemprop="url">服务无损下线实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-31 20:00:00 / 修改时间：16:00:36" itemprop="dateCreated datePublished" datetime="2023-01-31T20:00:00+08:00">2023-01-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/springcloud/" itemprop="url" rel="index">
                    <span itemprop="name">springcloud</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>服务关闭时，异常主要有两个场景</p>
<p>场景一： 服务关闭时，服务内部正在执行的请求未完成</p>
<p>场景二：服务下线后，其他调用者获取下线通知有延迟。造成短时间调用失败</p>
<p><img src="https://raw.githubusercontent.com/zhaoydo/pickgo_bed/master/img/image-20230131150918825.png" alt=""></p>
<p>Spring Boot 2.3新增了Graceful Shutdown，在服务关闭时，检查服务内部工作线程执行完毕后再结束服务，对于期间新请求全部HTTP 503拒绝。这种处理方式只解决了场景一，没有解决场景二的问题。</p>
<p>网上找到能同时解决两种场景的方案，只能自己实现了。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/01/31/server-shutdown/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/12/24/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaoyd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhaoyd's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/24/redis/" class="post-title-link" itemprop="url">Redis介绍</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-24 20:00:00" itemprop="dateCreated datePublished" datetime="2022-12-24T20:00:00+08:00">2022-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-12 11:22:01" itemprop="dateModified" datetime="2023-01-12T11:22:01+08:00">2023-01-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <a id="more"></a>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>redis是一个开源（BSD许可证）的内存结构存储，用作数据库、缓存、消息、消息代理和流引擎。提供string、hashes、lists、sets、<a href="https://redis.io/docs/data-types/sorted-sets/" target="_blank" rel="noopener">sorted sets</a> （有序集合）、bitmaps（位图）、hyperloglogs（用于基数统计）、geospatial indexes（地理空间索引）、 streams。 redis内置了复制、Lua脚本、LRU删除、事务和不同级别的磁盘持久化（RDB和AOF），并通过Redis Sentinel实现高可用，通过Redis Cluster实现自动分区。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>省略，参考官网<a href="https://redis.io/docs/getting-started/" target="_blank" rel="noopener">https://redis.io/docs/getting-started/</a></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>字符串，最基本的数据类型，包括text、序列化的对象、二进制数组。通常用于缓存，也能实现计数器和按位运算</p>
<p>默认一个字符串最多存储512MB的内容</p>
<h3 id="设置和获取对象"><a href="#设置和获取对象" class="headerlink" title="设置和获取对象"></a>设置和获取对象</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span>一个key</span></span><br><span class="line">SET user 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span>一个key，只有key不存在时才能设置成功</span></span><br><span class="line">SETNX user 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> get </span></span><br><span class="line">GET user</span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量获取key</span></span><br><span class="line">MGET user user1</span><br></pre></td></tr></table></figure>

<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置key自增1，如果key不存在，默认0 然后自增1</span></span><br><span class="line">INCR key</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置key自增指定的数量</span></span><br><span class="line">INCRBY key 5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同上，支持浮点数</span></span><br><span class="line">INCRBYFLOAT key 0.1</span><br></pre></td></tr></table></figure>

<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>参考后续的bitmap</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>字符串值的链表结构，最大长度是 2^32 - 1。用法有</p>
<ol>
<li>实现栈和队列</li>
<li>为后台工作系统构建队列管理</li>
</ol>
<h3 id="实现队列（先进先出）"><a href="#实现队列（先进先出）" class="headerlink" title="实现队列（先进先出）"></a>实现队列（先进先出）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 左侧插入元素1，返回长度。如果list不存在，新建一个</span></span><br><span class="line">LPUSH work:queue:ids 1</span><br><span class="line">(integer) 1</span><br><span class="line">LPUSH work:queue:ids 2</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 右侧取出元素</span></span><br><span class="line">RPOP work:queue:ids</span><br><span class="line">"1"</span><br><span class="line">RPOP work:queue:ids</span><br><span class="line">"2"</span><br></pre></td></tr></table></figure>

<h3 id="实现栈（先进后出）"><a href="#实现栈（先进后出）" class="headerlink" title="实现栈（先进后出）"></a>实现栈（先进后出）</h3><p>RPOP换成LPOP即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 左侧取出元素</span></span><br><span class="line">LPOP work:queue:ids</span><br></pre></td></tr></table></figure>

<h3 id="阻塞命令"><a href="#阻塞命令" class="headerlink" title="阻塞命令"></a>阻塞命令</h3><p>有点像java中的阻塞队列.如果list为空，则阻塞等待有新元素插入或者超时</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BLPOP work:queue:ids 10</span><br><span class="line">(nil)</span><br><span class="line">(10.00s)</span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>字符串值的无序、唯一集合，最大长度为 2^32 - 1 。 用法有</p>
<ol>
<li>维护唯一条目的集合（例如追踪一个博客文章的访问ip）</li>
<li>表示关系（例如一个角色的所有用户集合）</li>
<li>set常用的操作，交集、并集、差集</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加元素</span></span><br><span class="line">SADD user:123:favorites 347</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断元素是否存在</span></span><br><span class="line">SISMEMBER user:123:favorites 347</span><br><span class="line">(integer) 1</span><br><span class="line">SISMEMBER user:123:favorites 456</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取两个集合交集</span></span><br><span class="line">SINTER user:123:favorites user:456:favorites</span><br><span class="line">1) "347"</span><br><span class="line">2) "123"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取集合元素个数</span></span><br><span class="line">SCARD user:123:favorites</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>对于大型的数据集，集合元素检查可能会占用大量内存。 如果考虑内存占用，且不需要完美精度，考虑使用布隆过滤器or布谷过滤器替代。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Hash结构是field-value对的集合。 可以使用Hash表示基本对象和存储计数器分组。最大长度为 2^32 - 1 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设<span class="built_in">hash</span>元素多个field-value</span></span><br><span class="line">HSET user:123 username martina firstName Martina lastName Elisa country GB</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取某个field</span></span><br><span class="line">HGET user:123 username</span><br><span class="line">"martina"</span><br><span class="line"><span class="meta">#</span><span class="bash">设置key：device:777:stats field:pings 自增1</span></span><br><span class="line">HINCRBY device:777:stats pings 1</span><br><span class="line">(integer) 1</span><br><span class="line">HINCRBY device:777:stats pings 1</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取元素</span></span><br><span class="line">HGET device:777:stats pings</span><br><span class="line">"3"</span><br></pre></td></tr></table></figure>

<h2 id="Sorted-sets"><a href="#Sorted-sets" class="headerlink" title="Sorted sets"></a>Sorted sets</h2><p>Sorted sets是一个有序、唯一的集合，根据集合元素关联的score排序。如果score相同，按照字典顺序排序。</p>
<ol>
<li>排行榜</li>
<li>限流器，构建滑动窗口实现限流</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 向集合添加user:1 score：100</span></span><br><span class="line">ZADD leaderboard:455 100 user:1</span><br><span class="line">(integer) 1</span><br><span class="line">ZADD leaderboard:455 75 user:2</span><br><span class="line">(integer) 1</span><br><span class="line">ZADD leaderboard:455 101 user:3</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取top3的元素</span></span><br><span class="line">ZRANGE leaderboard:455 0 2 REV WITHSCORES</span><br><span class="line">1) "user:2"</span><br><span class="line">2) "275"</span><br><span class="line">3) "user:3"</span><br><span class="line">4) "101"</span><br><span class="line">5) "user:1"</span><br><span class="line">6) "100"</span><br><span class="line"><span class="meta">#</span><span class="bash">获取user:2 的排名</span></span><br><span class="line">ZREVRANK leaderboard:455 user:2</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/06/28/okhttp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaoyd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhaoyd's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/28/okhttp/" class="post-title-link" itemprop="url">okhttp源码解析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-28 22:00:00 / 修改时间：17:05:11" itemprop="dateCreated datePublished" datetime="2022-06-28T22:00:00+08:00">2022-06-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以okhttp_3.14.x作为示例代码，是最后一个java版本，后续版本使用了kotlin封装了部分实现。</p>
<h1 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h1><h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><p>官网示例代码SyncPost.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String postBody = <span class="string">""</span></span><br><span class="line">        + <span class="string">"Releases\n"</span></span><br><span class="line">        + <span class="string">"--------\n"</span></span><br><span class="line">        + <span class="string">"\n"</span></span><br><span class="line">        + <span class="string">" * _1.0_ May 6, 2013\n"</span></span><br><span class="line">        + <span class="string">" * _1.1_ June 15, 2013\n"</span></span><br><span class="line">        + <span class="string">" * _1.2_ August 11, 2013\n"</span>;</span><br><span class="line"></span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</span><br><span class="line">        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">        System.out.println(response.body().string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步请求调用了RealCall.execute()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步执行方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//先加个锁， 防止一个call被执行两次</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启scheduleTimeout，起一个watchDog线程，超时执行timeout()回调方法</span></span><br><span class="line">    transmitter.timeoutEnter();</span><br><span class="line">    <span class="comment">// 给EventListener发布一个callStart的事件</span></span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//核心调用逻辑在这里</span></span><br><span class="line">        <span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//执行完成 1、runningSyncCalls中移除call 2、执行idleCallback</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入getResponseWithInterceptorChain()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心方法，多个拦截器完成整个调用工作</span></span><br><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="comment">//这里可以看到，自定义的拦截器分两种， interceptors和networkInterceptors,执行顺序不一样</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一个拦截器，最终执行http调用（前一个拦截器依赖于后一个拦截器返回，注意执行顺序）</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line">    <span class="comment">//将拦截器数组封装为拦截器chain，递归调用，注意index</span></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">                                                       originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">                                                       client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Response response = chain.proceed(originalRequest);</span><br><span class="line">        <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">            closeQuietly(response);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">            transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把几个Interceptor封装为Interceptor.Chain，最后一个拦截器CallServerInterceptor最终执行了请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 拦截器，实际进行了http请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Exchange exchange = realChain.exchange();</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    exchange.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> responseHeadersStarted = <span class="keyword">false</span>;</span><br><span class="line">    Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这部分不好懂，理解大意</span></span><br><span class="line"><span class="comment">     * 如果有requestBody，并且请求头有Expect: 100-continue，在一次http连接内分两次传输</span></span><br><span class="line"><span class="comment">     * 第一次请求看服务器是否接受、第二次才发送大的requestBody。避免有的服务器不接受造成网络io浪费</span></span><br><span class="line"><span class="comment">     * 1、不带requestBody请求，服务器返回100说明允许requestBody</span></span><br><span class="line"><span class="comment">     * 2、获取httpcode 100后,将requestBody发送给服务器</span></span><br><span class="line"><span class="comment">     * 3、如果第一次发起请求不带Expect: 100-continue，服务器仍然返回了100。再读取一次httpcode（服务器默认按照1 2两部处理了）</span></span><br><span class="line"><span class="comment">     * 参考：https://blog.csdn.net/skh2015java/article/details/88723028</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span></span><br><span class="line">        <span class="comment">// Continue" response before transmitting the request body. If we don't get that, return</span></span><br><span class="line">        <span class="comment">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">            exchange.flushRequest();</span><br><span class="line">            responseHeadersStarted = <span class="keyword">true</span>;</span><br><span class="line">            exchange.responseHeadersStart();</span><br><span class="line">            responseBuilder = exchange.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.body().isDuplex()) &#123;</span><br><span class="line">                <span class="comment">// Prepare a duplex body so that the application can send a request body later.</span></span><br><span class="line">                exchange.flushRequest();</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                    exchange.createRequestBody(request, <span class="keyword">true</span>));</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                    exchange.createRequestBody(request, <span class="keyword">false</span>));</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exchange.noRequestBody();</span><br><span class="line">            <span class="keyword">if</span> (!exchange.connection().isMultiplexed()) &#123;</span><br><span class="line">                <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class="line">                <span class="comment">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class="line">                <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">                exchange.noNewExchangesOnConnection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        exchange.noRequestBody();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//requestBody已经写入exchange，将数据发送到服务器</span></span><br><span class="line">    <span class="keyword">if</span> (request.body() == <span class="keyword">null</span> || !request.body().isDuplex()) &#123;</span><br><span class="line">        exchange.finishRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!responseHeadersStarted) &#123;</span><br><span class="line">        exchange.responseHeadersStart();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进入这个if的条件是：</span></span><br><span class="line"><span class="comment">     * 1、requestHeader中有Expect: 100-continue并且服务器返回了100接受，再读取一次真正的返回</span></span><br><span class="line"><span class="comment">     * 2、requestHeader中无xpect: 100-continue（或者没有RequestBody），这里第一次读取返回header</span></span><br><span class="line"><span class="comment">     * 注意，这里只读取header，后面的exchange.openResponseBody(response)才读取responseBody</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有主动尝试100-continue，服务器也返回了100，这时候我们再获取一次响应</span></span><br><span class="line">    <span class="keyword">int</span> code = response.code();</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="comment">// server sent a 100-continue even though we did not request one.</span></span><br><span class="line">        <span class="comment">// try again to read the actual response</span></span><br><span class="line">        response = exchange.readResponseHeaders(<span class="keyword">false</span>)</span><br><span class="line">            .request(request)</span><br><span class="line">            .handshake(exchange.connection().handshake())</span><br><span class="line">            .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">        code = response.code();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">        <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .body(Util.EMPTY_RESPONSE)</span><br><span class="line">            .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//读取返回body</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .body(exchange.openResponseBody(response))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 服务器返回Connection:close 将exchange对应的connection标记不可用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">        || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">        exchange.noNewExchangesOnConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">            <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CallServerInterceptor中执行了http请求并读取返回。  可以看到对100-continue的处理，以及对Response分步读取。  </p>
<p>100-continue处理：</p>
<ol>
<li>不带requestBody请求，服务器返回100说明允许requestBody</li>
<li>获取httpcode 100后,将requestBody发送给服务器</li>
<li>如果第一次发起请求不带Expect: 100-continue，服务器仍然返回了100。再读取一次httpcode（服务器默认按照1 2两部处理了）</li>
</ol>
<blockquote>
<p>100-continue不影响主流程，不理解不影响看代码</p>
</blockquote>
<p>对请求结果的读取分两步：  </p>
<ol>
<li>读取ResponseHeader</li>
<li>读取ResponseBody</li>
</ol>
<h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>官网示例代码AsyncGet.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">        .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ResponseBody responseBody = response.body()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</span><br><span class="line"></span><br><span class="line">          Headers responseHeaders = response.headers();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = responseHeaders.size(); i &lt; size; i++) &#123;</span><br><span class="line">            System.out.println(responseHeaders.name(i) + <span class="string">": "</span> + responseHeaders.value(i));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          System.out.println(responseBody.string());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>调用了RealCall.enqueue()方法异步执行请求，请求完成后通过传入Callback的onResponse、onFailure处理成功、失败回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 异步请求方法，传入一个callback回调处理onFailure、onResponse</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> responseCallback</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发布一个callstart事件</span></span><br><span class="line">    transmitter.callStart();</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 异步执行方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> call</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">//加入到readyAsyncCalls队列（另一个runningAsyncCalls表示在调用中的call）</span></span><br><span class="line">      readyAsyncCalls.add(call);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span></span><br><span class="line">      <span class="comment">// the same host.</span></span><br><span class="line">      <span class="comment">//相同host的call共享callsPerHost，以便根据maxRequestsPerHost限制每个host并发请求数</span></span><br><span class="line">      <span class="keyword">if</span> (!call.get().forWebSocket) &#123;</span><br><span class="line">        AsyncCall existingCall = findExistingCallWithHost(call.host());</span><br><span class="line">        <span class="keyword">if</span> (existingCall != <span class="keyword">null</span>) call.reuseCallsPerHostFrom(existingCall);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    promoteAndExecute();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>两个enqueue很简单，将要调用Http请求的Call加入readyAsyncCalls队列，并调用promoteAndExecute();  </p>
<p>promoteAndExecute()方法的作用是将已提交的请求转入runningAsyncCalls，使用线程池执行，返回当前线程是否运行isRunning</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 把符合条件的call，由readyAsyncCalls =&gt; runningAsyncCalls，并塞入线程池执行</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否有运行中的call</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 调用此方法的四个地方</span></span><br><span class="line"><span class="comment">   * 1、修改maxRequests  修改参数后，可能有新的readyAsyncCalls符合条件可以执行了（例如从5修改为10）</span></span><br><span class="line"><span class="comment">   * 2、修改maxRequestsPerHost 同上</span></span><br><span class="line"><span class="comment">   * 3、enqueue()执行一个call</span></span><br><span class="line"><span class="comment">   * 4、finished() 一个runningCalls执行完成后，调用这个方法将执行下一个</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        AsyncCall asyncCall = i.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">        <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">        i.remove();</span><br><span class="line">        asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">        executableCalls.add(asyncCall);</span><br><span class="line">        runningAsyncCalls.add(asyncCall);</span><br><span class="line">      &#125;</span><br><span class="line">      isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">      AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">      asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>到这里，请求已经提交到线程池了，接下来看线程池执行的逻辑</p>
<p>AsyncCall继承了Runnable，线程池执行的是AsyncCall.run()方法,调用了execute()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AsyncCall.run()调用这个方法</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">    transmitter.timeoutEnter();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//和同步方法一样，调用一些列拦截器执行请求</span></span><br><span class="line">        Response response = getResponseWithInterceptorChain();</span><br><span class="line">        signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//调用成功回调，这里可能会抛出IOException</span></span><br><span class="line">        responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">            <span class="comment">//调用成功，onResponse失败</span></span><br><span class="line">            <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">            Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//调用失败</span></span><br><span class="line">            responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        cancel();</span><br><span class="line">        <span class="keyword">if</span> (!signalledCallback) &#123;</span><br><span class="line">            <span class="comment">//调用失败</span></span><br><span class="line">            IOException canceledException = <span class="keyword">new</span> IOException(<span class="string">"canceled due to "</span> + t);</span><br><span class="line">            canceledException.addSuppressed(t);</span><br><span class="line">            responseCallback.onFailure(RealCall.<span class="keyword">this</span>, canceledException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> t;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//完成调用，移除call和同步请求基本一致</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到本质还是调用了getResponseWithInterceptorChain()， 和同步方法一致，通过拦截器链完成http请求</p>
<h1 id="组件解析"><a href="#组件解析" class="headerlink" title="组件解析"></a>组件解析</h1><h2 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h2><p>再看前面的getResponseWithInterceptorChain()方法，把自定义的拦截器，和固定的拦截器组装为RealInterceptorChain</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 核心方法，多个拦截器完成整个调用工作</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="comment">//这里可以看到，自定义的拦截器分两种， interceptors和networkInterceptors,执行顺序不一样</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后一个拦截器，最终执行http调用（前一个拦截器依赖于后一个拦截器返回，注意执行顺序）</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line">    <span class="comment">//将拦截器数组封装为拦截器chain，递归调用，注意index</span></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Response response = chain.proceed(originalRequest);</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">        closeQuietly(response);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      calledNoMoreExchanges = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">        transmitter.noMoreExchanges(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/06/28/okhttp/interceptor.png" class="" title="interceptor image">

<p>代码很简单，直接看就ok</p>
<h3 id="两种自定义拦截器"><a href="#两种自定义拦截器" class="headerlink" title="两种自定义拦截器"></a>两种自定义拦截器</h3><p><img src="https://square.github.io/okhttp/assets/images/interceptors%402x.png" alt=""></p>
<p>两者区别，参考官网介绍。 简单说就是Application interceptors偏重功能，重试、重定向、缓存这些网络请求都不会影响。 Network Interceptors侧重实际执行，例如如果命中缓存没有发生网络请求，则不会调用。</p>
<p><strong>Application interceptors</strong></p>
<ul>
<li>Don’t need to worry about intermediate responses like redirects and retries.</li>
<li>Are always invoked once, even if the HTTP response is served from the cache.</li>
<li>Observe the application’s original intent. Unconcerned with OkHttp-injected headers like <code>If-None-Match</code>.</li>
<li>Permitted to short-circuit and not call <code>Chain.proceed()</code>.</li>
<li>Permitted to retry and make multiple calls to <code>Chain.proceed()</code>.</li>
<li>Can adjust Call timeouts using withConnectTimeout, withReadTimeout, withWriteTimeout.</li>
</ul>
<p><strong>Network Interceptors</strong></p>
<ul>
<li>Able to operate on intermediate responses like redirects and retries.</li>
<li>Not invoked for cached responses that short-circuit the network.</li>
<li>Observe the data just as it will be transmitted over the network.</li>
<li>Access to the <code>Connection</code> that carries the request.</li>
</ul>
<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><h4 id="http1-x-http2"><a href="#http1-x-http2" class="headerlink" title="http1.x/http2"></a>http1.x/http2</h4><p>客户端发起http请求到服务端，要经历DNS解析、TCP三次握手等一些列复杂过程才与服务器建立连接, 建立连接的过程开销很大。访问个普通网页，请求几十个甚至更多资源是很正常的。为了性能，大部分客户端对http请求做了连接复用。</p>
<p><strong>http1.x</strong></p>
<p>连接复用是通过请求头中的Connection:keep-alive实现的。服务端收到此请求头，响应请求后不会立即关闭连接，等待客户端发送下一个请求</p>
<p><strong>http2</strong></p>
<p>引入了多路复用机制，在一个http连接（或者说一个tcp连接）中可以并发发送多个http请求（对于http1.x，一个连接中多个http请求只能串行执行）</p>
<p>对于不同域名，一个ip:端口，也可以只维护一个http连接</p>
<blockquote>
<p> 对于http1.x chrome限制一个域名最大6个连接，多次http请求可能复用一个连接。也就是并发http请求数最大6个</p>
<p>对于http2，chrome在一个ip:端口下只维护1个连接，在1个连接内处理所有http请求</p>
</blockquote>
<p>http2下，http2.epean.com.cn可以使用http.epean.com.cn的connection</p>
<img src="/2022/06/28/okhttp/http2.png" class="" title="http2 image">



<blockquote>
<p>java8发布时还没有http2，java9及以上版本原生支持，java8需要引入第三方jar，并在启动参数中指定</p>
<p>-Xbootclasspath/p:/development/repository/org/mortbay/jetty/alpn/alpn-boot/8.1.12.v20180117/alpn-boot-8.1.12.v20180117.jar</p>
</blockquote>
<h4 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a>获取连接</h4><p>拦截器ConnectInterceptor中实现了获取连接的逻辑，很简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line">    <span class="comment">//get不用判断!source.exhausted()</span></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">//这里获取连接</span></span><br><span class="line">    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用exchangeFinder.findConnection()方法从线程池内获取到一个RealConnection。 看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1、尝试使用transmitter.connection已有的连接</span></span><br><span class="line"><span class="comment">   * 2、尝试根据host匹配连接</span></span><br><span class="line"><span class="comment">   * 3、尝试匹配所有routes，匹配ip、端口，找到可用的连接（http2）</span></span><br><span class="line"><span class="comment">   * 4、新创建一个连接，并把连接放入connectionPool</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> foundPooledConnection = <span class="keyword">false</span>;</span><br><span class="line">    RealConnection result = <span class="keyword">null</span>;</span><br><span class="line">    Route selectedRoute = <span class="keyword">null</span>;</span><br><span class="line">    RealConnection releasedConnection;</span><br><span class="line">    Socket toClose;</span><br><span class="line">    <span class="comment">// 第一次尝试 获取已有连接</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      hasStreamFailure = <span class="keyword">false</span>; <span class="comment">// This is a fresh attempt.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Attempt to use an already-allocated connection. We need to be careful here because our</span></span><br><span class="line">      <span class="comment">// already-allocated connection may have been restricted from creating new exchanges.</span></span><br><span class="line">      releasedConnection = transmitter.connection;</span><br><span class="line">      toClose = transmitter.connection != <span class="keyword">null</span> &amp;&amp; transmitter.connection.noNewExchanges</span><br><span class="line">          ? transmitter.releaseConnectionNoEvents()</span><br><span class="line">          : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (transmitter.connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We had an already-allocated connection and it's good.</span></span><br><span class="line">        result = transmitter.connection;</span><br><span class="line">        releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//第二次尝试，获取host匹配的连接</span></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Attempt to get a connection from the pool.</span></span><br><span class="line">        <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="keyword">null</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">          foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">          result = transmitter.connection;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextRouteToTry != <span class="keyword">null</span>) &#123;</span><br><span class="line">          selectedRoute = nextRouteToTry;</span><br><span class="line">          nextRouteToTry = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retryCurrentRoute()) &#123;</span><br><span class="line">          selectedRoute = transmitter.connection.route();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(toClose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (releasedConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      eventListener.connectionReleased(call, releasedConnection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// If we found an already-allocated or pooled connection, we're done.</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class="line">    <span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">      newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">      routeSelection = routeSelector.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Route&gt; routes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//第三次尝试 获取routes，匹配(http2不同域名相同ip、端口)</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">        <span class="comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class="line">        <span class="comment">// the pool. This could match due to connection coalescing.</span></span><br><span class="line">        routes = routeSelection.getAll();</span><br><span class="line">        <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(</span><br><span class="line">            address, transmitter, routes, <span class="keyword">false</span>)) &#123;</span><br><span class="line">          foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">          result = transmitter.connection;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">        <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">          selectedRoute = routeSelection.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个连接</span></span><br><span class="line">        <span class="comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class="line">        <span class="comment">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class="line">        result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">        connectingConnection = result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we found a pooled connection on the 2nd time around, we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">      eventListener.connectionAcquired(call, result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class="line">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">        connectionRetryEnabled, call, eventListener);</span><br><span class="line">    connectionPool.routeDatabase.connected(result.route());</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 第四次尝试， 获取routes，再次匹配(http2不同域名相同ip、端口)</span></span><br><span class="line">    <span class="comment">// 这里是为了方式第三步并发获取连接时，创建了两个连接。</span></span><br><span class="line">    <span class="comment">// 注意这里的requireMultiplexed=true，只获取http2的多路复用连接。http1连接可以有多个，http2连接1个就够了</span></span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">      connectingConnection = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// Last attempt at connection coalescing, which only occurs if we attempted multiple</span></span><br><span class="line">      <span class="comment">// concurrent connections to the same host.</span></span><br><span class="line">      <span class="comment">//如果能获取到，说明其他线程已经创建了http2多路复用的连接，将自己创建的连接释放掉</span></span><br><span class="line">      <span class="comment">//获取不到，将连接put到connectionPool</span></span><br><span class="line">      <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// We lost the race! Close the connection we created and return the pooled connection.</span></span><br><span class="line">        result.noNewExchanges = <span class="keyword">true</span>;</span><br><span class="line">        socket = result.socket();</span><br><span class="line">        result = transmitter.connection;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// It's possible for us to obtain a coalesced connection that is immediately unhealthy. In</span></span><br><span class="line">        <span class="comment">// that case we will retry the route we just successfully connected with.</span></span><br><span class="line">        nextRouteToTry = selectedRoute;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connectionPool.put(result);</span><br><span class="line">        transmitter.acquireConnectionNoEvents(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closeQuietly(socket);</span><br><span class="line"></span><br><span class="line">    eventListener.connectionAcquired(call, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>代码很长，但是逻辑很清晰，分4步</p>
<ol>
<li>尝试使用transmitter.connection已有的连接</li>
<li>尝试从连接池获取连接，根据连接的host匹配</li>
<li>尝试从routeSelector获取routes，匹配相同ip、端口（http2）</li>
<li>创建一个新的连接，put到线程池</li>
</ol>
<p>注意第四步时的并发处理,http2多路复用的情况下，只创建1个连接</p>
<h4 id="连接清理"><a href="#连接清理" class="headerlink" title="连接清理"></a>连接清理</h4><p>在新创建连接，塞入连接池时执行清理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">//如果当前没有清理，执行</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">        cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">        executor.execute(cleanupRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建的连接添加到连接池中</span></span><br><span class="line">    connections.add(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cleanupRunnable，配合cleanup方法一起看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = () -&gt; &#123;</span><br><span class="line">    <span class="comment">//waitNanos -1 退出清理 &gt;0 wait(waitNanos)后继续  0 立即继续</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">      <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">        waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (RealConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            RealConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>重点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清除闲置的connection</span></span><br><span class="line"><span class="comment">   * return 下一次执行清除线程毫秒数</span></span><br><span class="line"><span class="comment">   * 0 清除线程执行了一次，立即执行下一次cleanup</span></span><br><span class="line"><span class="comment">   * &gt;0 case1 有闲置线程，wait(keepAliveDurationNs - longestIdleDurationNs)到闲置时间满后执行</span></span><br><span class="line"><span class="comment">   * &gt;0 case2 无闲置线程，有线程在使用，wait(keepAliveDurationNs)后继续执行</span></span><br><span class="line"><span class="comment">   * -1 没有任何线程，cleanupRunning=false 退出线程清理循环</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        RealConnection connection = i.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the connection is in use, keep searching.</span></span><br><span class="line">        <span class="comment">// 连接在用, continue下一个</span></span><br><span class="line">        <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          inUseConnectionCount++;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//空置连接</span></span><br><span class="line">        idleConnectionCount++;</span><br><span class="line">        <span class="comment">//计算空闲时间，找到闲置最久的connection</span></span><br><span class="line">        <span class="comment">// If the connection is ready to be evicted, we're done.</span></span><br><span class="line">        <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">        <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">          longestIdleDurationNs = idleDurationNs;</span><br><span class="line">          longestIdleConnection = connection;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果超出了最大闲置时间 or 最大闲置连接数，移除</span></span><br><span class="line">      <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">          || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">        <span class="comment">// We've found a connection to evict. Remove it from the list, then close it below (outside</span></span><br><span class="line">        <span class="comment">// of the synchronized block).</span></span><br><span class="line">        connections.remove(longestIdleConnection);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// A connection will be ready to evict soon.</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// All connections are in use. It'll be at least the keep alive duration 'til we run again.</span></span><br><span class="line">        <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No connections, idle or in use.</span></span><br><span class="line">        cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cleanup again immediately.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>循环执行cleanup()清理超出keepAliveDurationNs,maxIdleConnections的线程，如果当前没有可以清理的闲置线程，计算出下个预计有线程空闲的时间，wait()后继续循环。直到线程池内无任何线程结束循环</p>
<img src="/2022/06/28/okhttp/liucheng.png" class="" title="elk image">

<h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><p>主要是一些变量的定义与调用方法，直接看注释很简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调度器，异步请求用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调度器最大并发请求数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;</span><br><span class="line">  <span class="comment">//每个host最大并发数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;</span><br><span class="line">  <span class="comment">//线程池空闲时回调（isRunning 1=&gt;0时触发）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Runnable idleCallback;</span><br><span class="line">  <span class="comment">//异步执行线程池</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> ExecutorService executorService;</span><br><span class="line">  <span class="comment">// 已加入调度器的Call</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="comment">// 线程池内正在运行的Call</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="comment">//同步的call，统计用，例如计算线程池是否空闲isRunning</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.executorService = executorService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//默认初始化一个核心0，无上限的线程池（实际上限取决于maxRequests）</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//SynchronousQueue 是无缓冲队列，不缓存Call，直接创建线程</span></span><br><span class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">          <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//异步执行方法  省略</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span></span></span><br><span class="line"><span class="function">  <span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment">   * 把符合条件的call，由readyAsyncCalls =&gt; runningAsyncCalls，并塞入线程池执行</span></span></span><br><span class="line"><span class="function"><span class="comment">   * @return 是否有运行中的call</span></span></span><br><span class="line"><span class="function"><span class="comment">   *</span></span></span><br><span class="line"><span class="function"><span class="comment">   * 调用此方法的四个地方</span></span></span><br><span class="line"><span class="function"><span class="comment">   * 1、修改maxRequests  修改参数后，可能有新的readyAsyncCalls符合条件可以执行了（例如从5修改为10）</span></span></span><br><span class="line"><span class="function"><span class="comment">   * 2、修改maxRequestsPerHost 同上</span></span></span><br><span class="line"><span class="function"><span class="comment">   * 3、enqueue()执行一个call</span></span></span><br><span class="line"><span class="function"><span class="comment">   * 4、finished() 一个runningCalls执行完成后，调用这个方法将执行下一个</span></span></span><br><span class="line"><span class="function"><span class="comment">   */</span></span></span><br><span class="line"><span class="function">  <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">promoteAndExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> (!Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">        AsyncCall asyncCall = i.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">        <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line"></span><br><span class="line">        i.remove();</span><br><span class="line">        asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">        executableCalls.add(asyncCall);</span><br><span class="line">        runningAsyncCalls.add(asyncCall);</span><br><span class="line">      &#125;</span><br><span class="line">      isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">      AsyncCall asyncCall = executableCalls.get(i);</span><br><span class="line">      asyncCall.executeOn(executorService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isRunning;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * call执行完毕</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="comment">//将call从runningAsyncCalls/runningSyncCalls队列中移除</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">      idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把符合条件的call，由readyAsyncCalls =&gt; runningAsyncCalls，并塞入线程池执行。</span></span><br><span class="line">    <span class="keyword">boolean</span> isRunning = promoteAndExecute();</span><br><span class="line">    <span class="comment">//线程池空闲，执行idleCallback回调</span></span><br><span class="line">    <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意maxRequests和executorService()这两个参数。 默认初始化maxRequests=64，线程池数量无上限，实际请求数/线程数取两者最小值。两个参数哪个大对性能无影响。</p>
<h1 id="okhttp结构"><a href="#okhttp结构" class="headerlink" title="okhttp结构"></a>okhttp结构</h1><p><img src="https://img-blog.csdnimg.cn/20210630103500293.png" alt=""></p>
<p>懒得画了，网上找了个，很简单。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="几个主要组件"><a href="#几个主要组件" class="headerlink" title="几个主要组件"></a>几个主要组件</h2><ol>
<li>RealInterceptorChain 一系列拦截器实现http请求</li>
<li>ExchangeFinder.findConnection() 从线程池内找出可用连接，http1连接和http2可复用连接处理</li>
<li>Dispatcher 异步http请求调度器</li>
</ol>
<h2 id="用到的设计模式"><a href="#用到的设计模式" class="headerlink" title="用到的设计模式"></a>用到的设计模式</h2><ol>
<li>责任链模式，RealInterceptorChain </li>
<li>建造者模式 OkHttpClient.build()</li>
<li>工厂模式 EventListener.Factory.create</li>
<li>代理模式(RealCall/Call),委派模式(RealConnectionPool/ConnectionPool)等</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">okhttp官网</a></p>
<p><a href="https://blog.csdn.net/Giagor/article/details/122019377" target="_blank" rel="noopener">okhttp连接池建立与复用</a></p>
<p><a href="https://juejin.cn/post/6844903577006129159" target="_blank" rel="noopener">http2简介</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/22/sharding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaoyd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhaoyd's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/22/sharding/" class="post-title-link" itemprop="url">sharding</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-22 17:38:42" itemprop="dateCreated datePublished" datetime="2022-02-22T17:38:42+08:00">2022-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-30 12:29:00" itemprop="dateModified" datetime="2022-05-30T12:29:00+08:00">2022-05-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<hr>
<blockquote>
<p>本文只讨论水平分表，垂直分表属于业务重构问题</p>
</blockquote>
<h1 id="为什么分表"><a href="#为什么分表" class="headerlink" title="为什么分表"></a>为什么分表</h1><p>参考下图，t_user表根据业务字段id拆分，奇数放入table1，偶数放入table2<br><img src="https://shardingsphere.apache.org/document/current/img/sharding/horizontal_sharding.png" alt="水平分片"></p>
<p>通过一个或多个字段/规则将数据分散到多个数据库、数据表中，使得业务数据突破单表性能瓶颈。  </p>
<p>为什么效率高：  </p>
<ol>
<li>减少单表数据、索引大小，提高读写效率</li>
<li>开多个线程并发读写分片数据（十个线程分别从一千万表中读 VS 一个线程从一亿表中读）</li>
<li>提前缩小读写范围，sql条件中有id（分片列），只需要读写对应分片表即可</li>
</ol>
<p>带来的问题：  </p>
<ol>
<li>分表后表结构维护，数据运维</li>
<li>多线程写、跨库写时事务问题</li>
<li>复杂sql，insert into select,分表字段列update、limit、order by、group by某些情况下不能正确执行</li>
</ol>
<blockquote>
<p>举个例子 TODO</p>
</blockquote>
<h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><table>
<thead>
<tr>
<th></th>
<th>ShardingJDBC</th>
<th>Mycat</th>
</tr>
</thead>
<tbody><tr>
<td>分库</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>分表</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>实现方式</td>
<td>解析改写SQL</td>
<td>中间层代理</td>
</tr>
<tr>
<td>性能</td>
<td>损耗低</td>
<td>损耗略高</td>
</tr>
<tr>
<td>使用</td>
<td>引用jar包</td>
<td>需单独安装管理端</td>
</tr>
<tr>
<td>社区</td>
<td>star 15.1k Apache-2.0许可</td>
<td>star 9.2k GPL-2.0许可</td>
</tr>
<tr>
<td>官网</td>
<td><a href="https://shardingsphere.apache.org/" target="_blank" rel="noopener">https://shardingsphere.apache.org/</a></td>
<td><a href="http://mycat.org.cn/" target="_blank" rel="noopener">http://mycat.org.cn/</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>选择ShardingJDBC， 分表性能损耗低，实现方式容易理解，无需单独安装服务端。 11月刚发布了5.0正式版</p>
<blockquote>
<p>ShardingJDBC4.0后，官方将ShardingJDBC、ShardingProxy统一为ShardingSphere</p>
</blockquote>
<h1 id="ShardingJDBC"><a href="#ShardingJDBC" class="headerlink" title="ShardingJDBC"></a>ShardingJDBC</h1><h2 id="内置分片算法"><a href="#内置分片算法" class="headerlink" title="内置分片算法"></a>内置分片算法</h2><table>
<thead>
<tr>
<th align="left"><em>SPI 名称</em></th>
<th align="left"><em>详细说明</em></th>
</tr>
</thead>
<tbody><tr>
<td align="left">ShardingAlgorithm</td>
<td align="left">分片算法</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left"><em>已知实现类</em></th>
<th align="left"><em>详细说明</em></th>
</tr>
</thead>
<tbody><tr>
<td align="left">BoundaryBasedRangeShardingAlgorithm</td>
<td align="left">基于分片边界的范围分片算法</td>
</tr>
<tr>
<td align="left">VolumeBasedRangeShardingAlgorithm</td>
<td align="left">基于分片容量的范围分片算法</td>
</tr>
<tr>
<td align="left">ComplexInlineShardingAlgorithm</td>
<td align="left">基于行表达式的复合分片算法</td>
</tr>
<tr>
<td align="left">AutoIntervalShardingAlgorithm</td>
<td align="left">基于可变时间范围的分片算法</td>
</tr>
<tr>
<td align="left">ClassBasedShardingAlgorithm</td>
<td align="left">基于自定义类的分片算法</td>
</tr>
<tr>
<td align="left">HintInlineShardingAlgorithm</td>
<td align="left">基于行表达式的Hint分片算法</td>
</tr>
<tr>
<td align="left">IntervalShardingAlgorithm</td>
<td align="left">基于固定时间范围的分片算法</td>
</tr>
<tr>
<td align="left">HashModShardingAlgorithm</td>
<td align="left">基于哈希取模的分片算法</td>
</tr>
<tr>
<td align="left">InlineShardingAlgorithm</td>
<td align="left">基于行表达式的分片算法</td>
</tr>
<tr>
<td align="left">ModShardingAlgorithm</td>
<td align="left">基于取模的分片算法</td>
</tr>
</tbody></table>
<p>官方提供了几种常用的分片算法，分为三大类</p>
<h3 id="精确分片算法"><a href="#精确分片算法" class="headerlink" title="精确分片算法"></a>精确分片算法</h3><p>根据分片key，直接计算出数据表，一般用于非范围分片key，buyerId，orderId等</p>
<h4 id="InlineShardingAlgorithm"><a href="#InlineShardingAlgorithm" class="headerlink" title="InlineShardingAlgorithm"></a>InlineShardingAlgorithm</h4><p>根据表达式t_order_$-&gt;{order_id % 4}，计算分片表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inlineShardingAlgorithm = <span class="keyword">new</span> InlineShardingAlgorithm();</span><br><span class="line">        inlineShardingAlgorithm.getProps().setProperty(<span class="string">"algorithm-expression"</span>, <span class="string">"t_order_$-&gt;&#123;order_id % 4&#125;"</span>);</span><br><span class="line">        inlineShardingAlgorithm.getProps().setProperty(<span class="string">"allow-range-query-with-inline-sharding"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>



<h4 id="ComplexInlineShardingAlgorithm"><a href="#ComplexInlineShardingAlgorithm" class="headerlink" title="ComplexInlineShardingAlgorithm"></a>ComplexInlineShardingAlgorithm</h4><p>多个分片key  </p>
<p>t_order表根据type、order列分表，分片表为t_order_0_0、t_order_0_1、t_order_1_0、t_order_1_1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">complexInlineShardingAlgorithm = <span class="keyword">new</span> ComplexInlineShardingAlgorithm();</span><br><span class="line">complexInlineShardingAlgorithm.getProps().setProperty(<span class="string">"algorithm-expression"</span>, <span class="string">"t_order_$&#123;type % 2&#125;_$&#123;order_id % 2&#125;"</span>);</span><br><span class="line">complexInlineShardingAlgorithm.getProps().setProperty(<span class="string">"sharding-columns"</span>, <span class="string">"type,order_id"</span>);</span><br><span class="line">complexInlineShardingAlgorithm.init();</span><br></pre></td></tr></table></figure>

<h4 id="HashModShardingAlgorithm"><a href="#HashModShardingAlgorithm" class="headerlink" title="HashModShardingAlgorithm"></a>HashModShardingAlgorithm</h4><p>将t_order根据buyer_id(varchar 20) hash后分为四片，  key.hashCode()%4, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shardingAlgorithm &#x3D; new HashModShardingAlgorithm();</span><br><span class="line">        shardingAlgorithm.getProps().setProperty(&quot;sharding-count&quot;, &quot;4&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="HintInlineShardingAlgorithm"><a href="#HintInlineShardingAlgorithm" class="headerlink" title="HintInlineShardingAlgorithm"></a>HintInlineShardingAlgorithm</h4><p>强制指定要查询的表，不根据SQL解析。例如下面代码查询表为t_order_0%4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hintInlineShardingAlgorithm = <span class="keyword">new</span> HintInlineShardingAlgorithm();</span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.setProperty(<span class="string">"algorithm-expression"</span>, <span class="string">"t_order_$-&gt;&#123;value % 4&#125;"</span>);</span><br><span class="line">hintInlineShardingAlgorithm.setProps(props);</span><br><span class="line">hintInlineShardingAlgorithm.init();</span><br><span class="line"><span class="comment">//手动指定分片</span></span><br><span class="line"><span class="keyword">final</span> HintManager hintManager = HintManager.getInstance();</span><br><span class="line">hintManager.addTableShardingValue(<span class="string">"t_order"</span>, <span class="number">0</span>);</span><br><span class="line">orderService.get(<span class="number">122343L</span>);</span><br></pre></td></tr></table></figure>



<h3 id="范围分片算法"><a href="#范围分片算法" class="headerlink" title="范围分片算法"></a>范围分片算法</h3><p>根据设置的分片key范围，定位数据表。datetime、id等</p>
<h4 id="BoundaryBasedRangeShardingAlgorithm"><a href="#BoundaryBasedRangeShardingAlgorithm" class="headerlink" title="BoundaryBasedRangeShardingAlgorithm"></a>BoundaryBasedRangeShardingAlgorithm</h4><p>自定义分片边界算法</p>
<p>-∞~10000  table0  </p>
<p>10000~20000 table1  </p>
<p>20000~30000 table2    </p>
<p>30000~∞ table3  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BoundaryBasedRangeShardingAlgorithm shardingAlgorithm = <span class="keyword">new</span>           BoundaryBasedRangeShardingAlgorithm();</span><br><span class="line">    shardingAlgorithm.getProps().setProperty(<span class="string">"sharding-ranges"</span>, <span class="string">"10000,20000,30000"</span>);</span><br><span class="line">    shardingAlgorithm.init();</span><br></pre></td></tr></table></figure>



<h3 id="容量分片算法"><a href="#容量分片算法" class="headerlink" title="容量分片算法"></a>容量分片算法</h3><p>其实就是范围分片的变种，分片规则以容量配置，一般用于有序并知道预期范围分片key</p>
<h4 id="VolumeBasedRangeShardingAlgorithm"><a href="#VolumeBasedRangeShardingAlgorithm" class="headerlink" title="VolumeBasedRangeShardingAlgorithm"></a>VolumeBasedRangeShardingAlgorithm</h4><p>自定义分片容量</p>
<p>分片key预期在0-100万，将此区间内数据均匀分片，每片最多10万数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VolumeBasedRangeShardingAlgorithm shardingAlgorithm = <span class="keyword">new</span> VolumeBasedRangeShardingAlgorithm();</span><br><span class="line">shardingAlgorithm.getProps().setProperty(<span class="string">"range-lower"</span>, <span class="string">"0"</span>);</span><br><span class="line">shardingAlgorithm.getProps().setProperty(<span class="string">"range-upper"</span>, <span class="string">"1000000"</span>);</span><br><span class="line">shardingAlgorithm.getProps().setProperty(<span class="string">"sharding-volume"</span>, <span class="string">"100000"</span>);</span><br><span class="line">shardingAlgorithm.init();</span><br></pre></td></tr></table></figure>

<h4 id="AutoIntervalShardingAlgorithm"><a href="#AutoIntervalShardingAlgorithm" class="headerlink" title="AutoIntervalShardingAlgorithm"></a>AutoIntervalShardingAlgorithm</h4><p>根据分片key时间均分  </p>
<p>t_order表 根据order_time（预期20年-21年），每天分一片，分片表为t_order_0，t_order_1…t_order_366</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shardingAlgorithm = <span class="keyword">new</span> AutoIntervalShardingAlgorithm();</span><br><span class="line">        shardingAlgorithm.getProps().setProperty(<span class="string">"datetime-lower"</span>, <span class="string">"2020-01-01 00:00:00"</span>);</span><br><span class="line">        shardingAlgorithm.getProps().setProperty(<span class="string">"datetime-upper"</span>, <span class="string">"2021-01-01 00:00:16"</span>);</span><br><span class="line">        shardingAlgorithm.getProps().setProperty(<span class="string">"sharding-seconds"</span>, String.valueOf(<span class="number">3600</span>*<span class="number">24</span>));</span><br><span class="line">        shardingAlgorithm.init();</span><br></pre></td></tr></table></figure>

<h4 id="IntervalShardingAlgorithm"><a href="#IntervalShardingAlgorithm" class="headerlink" title="IntervalShardingAlgorithm"></a>IntervalShardingAlgorithm</h4><p>基于时间单位分片  </p>
<p>t_order 根据order_time，每月分一片，分片表为t_order_0,t_order_1，t_order_2…t_order_59</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shardingAlgorithmByMonth = <span class="keyword">new</span> IntervalShardingAlgorithm();</span><br><span class="line">       shardingAlgorithmByMonth.getProps().setProperty(<span class="string">"datetime-pattern"</span>, <span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">       shardingAlgorithmByMonth.getProps().setProperty(<span class="string">"datetime-lower"</span>, <span class="string">"2016-01-01 00:00:00"</span>);</span><br><span class="line">       shardingAlgorithmByMonth.getProps().setProperty(<span class="string">"datetime-upper"</span>, <span class="string">"2021-12-31 00:00:00"</span>);</span><br><span class="line">       shardingAlgorithmByMonth.getProps().setProperty(<span class="string">"sharding-suffix-pattern"</span>, <span class="string">"yyyyMM"</span>);</span><br><span class="line">       shardingAlgorithmByMonth.getProps().setProperty(<span class="string">"datetime-interval-amount"</span>, <span class="string">"1"</span>);</span><br><span class="line">       shardingAlgorithmByMonth.getProps().setProperty(<span class="string">"datetime-interval-unit"</span>, <span class="string">"Months"</span>);</span><br><span class="line">       shardingAlgorithmByMonth.init();</span><br></pre></td></tr></table></figure>

<h3 id="自定义算法"><a href="#自定义算法" class="headerlink" title="自定义算法"></a>自定义算法</h3><p>自己实现分片规则</p>
<h4 id="ClassBasedShardingAlgorithm"><a href="#ClassBasedShardingAlgorithm" class="headerlink" title="ClassBasedShardingAlgorithm"></a>ClassBasedShardingAlgorithm</h4><p>自定义类分片算法</p>
<p>最灵活的分片算法，任意实现业务逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shardingAlgorithm = <span class="keyword">new</span> ClassBasedShardingAlgorithm();</span><br><span class="line">        shardingAlgorithm.getProps().setProperty(<span class="string">"strategy"</span>, <span class="string">"standard"</span>);</span><br><span class="line">        shardingAlgorithm.getProps().setProperty(<span class="string">"algorithmClassName"</span>, ClassBasedStandardShardingAlgorithmFixture<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        shardingAlgorithm.init();</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><p>application-dev.properties</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 直接看项目配置</span><br></pre></td></tr></table></figure>

<p>TradeMybatisConfigurer.java 定义主数据源</p>
<h2 id="动态数据源切换"><a href="#动态数据源切换" class="headerlink" title="动态数据源切换"></a>动态数据源切换</h2><p>将分表数据源定义为主数据源，对于某些SQL，ShardingJDBC不支持，这种情况需要我们手动切换为普通数据源（druid）</p>
<p>使用Spring提供的AbstractRoutingDataSource实现数据源切换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态事务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhaoyd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021-12-27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;DataSourceKeyEnum&gt; CONTEXT_HOLDER = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultTargetDataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetDataSources</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicDataSource</span><span class="params">(DataSource defaultTargetDataSource, Map&lt;Object, Object&gt; targetDataSources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setDefaultTargetDataSource(defaultTargetDataSource);</span><br><span class="line">        <span class="keyword">super</span>.setTargetDataSources(targetDataSources);</span><br><span class="line">        <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDataSourceKey();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSourceKey</span><span class="params">(DataSourceKeyEnum dataSource)</span> </span>&#123;</span><br><span class="line">        CONTEXT_HOLDER.set(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSourceKeyEnum <span class="title">getDataSourceKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CONTEXT_HOLDER.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDataSourceKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CONTEXT_HOLDER.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义数据源切换注解@EnableDataSource(DataSourceKeyEnum)，通过AOP拦截下注解。很简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并所有订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@EnableDataSource</span>(DataSourceKeyEnum.TRADE)<span class="comment">//表示使用非分片的druid数据源</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"mergeallorder.html"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonDataDto <span class="title">mergeAllOrder</span><span class="params">(PlatOrderMergeSearchDto queryBean, HttpServletRequest request)</span> <span class="keyword">throws</span> BaseAppException</span>&#123;</span><br><span class="line">        Boolean isIgnoreLogis = BooleanUtils.toBoolean(request.getParameter(<span class="string">"isIgnoreLogis"</span>));</span><br><span class="line">        AssertUtils.notNull(isIgnoreLogis);</span><br><span class="line">        List&lt;String&gt; mergeResult = mergeOrderBusiService.mergeAllOrder(queryBean, isIgnoreLogis);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonDataDto(mergeResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h1><p>分表后，无法使用单表自增ID，需要使用分布式ID方案来生成唯一ID  </p>
<p>分布式ID方案有三种</p>
<table>
<thead>
<tr>
<th></th>
<th>示例</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>UUID</td>
<td>91c606f6-d87f-4dd1-80b2-414b6ac38ad0</td>
<td>无单点问题，实现最简单</td>
<td>无序，32位字符串长，可读性差</td>
</tr>
<tr>
<td>号段模式</td>
<td>211790001-211800001（Long）</td>
<td>效率高，趋势递增，和自增ID基本一致</td>
<td>依赖单点生成，实现复杂(需解决并发)</td>
</tr>
<tr>
<td>雪花算法</td>
<td><img src="https://pic4.zhimg.com/80/v2-0ca4a4125b1cbda69cfa972b1e568ffb_720w.jpg" alt=""></td>
<td>无单点问题，效率高，趋势递增有可读性</td>
<td>64位太长，需要解决时钟回拨问题</td>
</tr>
</tbody></table>
<blockquote>
<p>时钟回拨： 服务器每隔一段时间会从网络时钟服务器校时，如果某次校时，由15:01退回到15:00.这时候ID就会重复。  </p>
<p>大部分解决时钟回拨的方法是服务将历史一段时间内（例如一小时）每个毫秒的最大自增序号保存起来</p>
</blockquote>
<p>项目采用的是号段模式，主要考虑到下面几点  </p>
<ol>
<li>雪花算法需要对每台应用单独维护一个workerID，无论是配置文件直接配置还是通过redis、zookeeper注册都很麻烦，<a href="https://blog.csdn.net/u013465194/article/details/83385198" target="_blank" rel="noopener">看这个</a></li>
<li>UUID需要修改ID数据类型，而且是无序的。插入数据时会重构索引B+树（回忆下白泽上树老师的mysql分享），占用空间大</li>
<li>号段模式生成ID，在数据格式，长度和原来自增一致，唯一缺点时不能保证严格的自增（两台cps申请号段分别为100-200,200-300，会出现id=250的create_time 小于id=150的情况）</li>
</ol>
<h3 id="号段模式实现"><a href="#号段模式实现" class="headerlink" title="号段模式实现"></a>号段模式实现</h3><ol>
<li>数据库维护一张号段表，每台服务根据biz_tag取一定长度的号段，放在服务内号段缓存中</li>
<li>每次数据插入，先从服务内号段缓存取一个id，如果缓存用完，则从号段表中初再初始化一批号段</li>
</ol>
<table>
<thead>
<tr>
<th>biz_tag</th>
<th>next_id</th>
<th>step</th>
<th>remark</th>
<th>update_time</th>
</tr>
</thead>
<tbody><tr>
<td>prod_sync_p_shopee</td>
<td>211790001</td>
<td>10000</td>
<td>shopee同步父表</td>
<td>2022-1-6 22:26</td>
</tr>
<tr>
<td>prod_sync_s_shopee</td>
<td>750310001</td>
<td>10000</td>
<td>shopee同步子表</td>
<td>2022-1-6 23:18</td>
</tr>
<tr>
<td>test</td>
<td>1</td>
<td>100</td>
<td>test</td>
<td>2021-11-24 15:33</td>
</tr>
</tbody></table>
<p>给实体类加上注解即可，实现细节：SegmentIdGenerator.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdSyncPShopee</span> <span class="keyword">extends</span> <span class="title">ShardingBaseBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@KeySql</span>(genId = SegmentIdGenerator<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Long</span> <span class="title">id</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><blockquote>
<p> 思考一个问题，前面说分表时以多线程执行每个分片SQL，事务如何处理</p>
</blockquote>
<p>ShardingJDBC默认使用本地事务，支持绝大部分单应用场景下跨库和非跨库事务。<a href="https://shardingsphere.apache.org/document/current/cn/features/transaction/use-norms/" target="_blank" rel="noopener">官网说明</a></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>事务</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>普通sql</td>
<td>支持</td>
<td>单个事务连接commit or rollback</td>
</tr>
<tr>
<td>分表SQL</td>
<td>支持</td>
<td>多个事务连接commit or rollback，不能处理commit阶段异常(数据库宕机、网络中断)</td>
</tr>
<tr>
<td>分库SQL</td>
<td>支持</td>
<td>多个事务连接commit or rollback，不能处理commit阶段异常(数据库宕机、网络中断)</td>
</tr>
</tbody></table>
<p>源码中本地事务的实现如下</p>
<blockquote>
<p>对prod_sync_p_shopee表根据id更新，测试库分了三张表，开启三条数据库连接并发执行update语句</p>
</blockquote>
<p>提交事务，遍历当前事务所有的事务Connection，依次执行commit()</p>
<p><img src="http://zentao.epean.cn/zentao/file-read-11179.png" alt="commit"></p>
<p>异常时回滚事务，遍历当前事务打开的所有事务Connection，依次执行rollback()回滚数据</p>
<p><img src="http://zentao.epean.cn/zentao/file-read-11180.png" alt="rollback"></p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="提前初始化陷阱"><a href="#提前初始化陷阱" class="headerlink" title="提前初始化陷阱"></a>提前初始化陷阱</h2><p>提前初始化导致事务失效</p>
<p>shiroFilter引入了UserService。 导致bean在BeanPostProcessor之前被初始化，AOP基于BeanPostProcessor实现事务导致相关的bean不生效</p>
<p>详细看这个：<a href="https://www.jianshu.com/p/b1209cd3686d" target="_blank" rel="noopener">引入shiro后userService事务不生效原因</a></p>
<h2 id="分表关联笛卡尔积"><a href="#分表关联笛卡尔积" class="headerlink" title="分表关联笛卡尔积"></a>分表关联笛卡尔积</h2><p>父子表10*10 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_parent <span class="keyword">as</span> p <span class="keyword">inner</span> <span class="keyword">join</span> t_detail <span class="keyword">as</span> d <span class="keyword">on</span> d.p_id=p.id</span><br></pre></td></tr></table></figure>

<p>如果父子表都有分表，会关联t_parent0-9 * t_detail0_9 执行100条sql语句</p>
<p>解决方案是绑定父子表分片，这样t_parent_0至于t_detail_0 连接查询，执行10条sql语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.shardingsphere.rules.sharding.binding-tables[0]&#x3D;t_parent,t_detail</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个问题在生产上造成了两周系统卡顿，没仔细阅读官网文档</p>
</blockquote>
<h2 id="特殊SQL支持"><a href="#特殊SQL支持" class="headerlink" title="特殊SQL支持"></a>特殊SQL支持</h2><p>特殊的sql不支持，类似下面这些</p>
<p>insert into select * from xxx;</p>
<p>left join 分表table</p>
<p>非分表table相关sql用动态数据源注解切换为普通数据源。分表table改写sql用其他方式实现</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上线分表后有两个问题</p>
<ol>
<li>未做父子表关联绑定，查询笛卡尔积，导致生产系统两周数据库高负载。父子分片绑定后解决</li>
<li>部分sql不支持，报错。 统一排查报错原因一个个改</li>
</ol>
<p>分表看起来香，落地难。要解决数据源、事务、分布式id、特殊sql处理这些问题，还不太成熟。如果从0设计一个系统，会倾向于分布式数据库。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://shardingsphere.apache.org/document/5.0.0/en/overview/" target="_blank" rel="noopener">ShardingSphere官网文档</a></p>
<p><a href="https://www.cnblogs.com/wuer888/p/14531046.html" target="_blank" rel="noopener">ShardingJDBC分片算法和解析流程</a></p>
<p><a href="https://tech.meituan.com/2019/03/07/open-source-project-leaf.html" target="_blank" rel="noopener">美团分布式ID生成服务</a></p>
<p><a href="https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html" target="_blank" rel="noopener">大众点评订单系统分库分表实践</a></p>
<p><a href="https://www.cnblogs.com/qlqwjy/p/13423021.html" target="_blank" rel="noopener">基于AbstractRoutingDataSource实现动态数据源</a></p>
<p><a href="https://www.jianshu.com/p/b1209cd3686d" target="_blank" rel="noopener">引入shiro后userService事务不生效原因</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/24/elk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaoyd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhaoyd's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/24/elk/" class="post-title-link" itemprop="url">ELK+Filebeat实现日志收集</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-24 20:39:00" itemprop="dateCreated datePublished" datetime="2021-09-24T20:39:00+08:00">2021-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-26 19:00:44" itemprop="dateModified" datetime="2021-09-26T19:00:44+08:00">2021-09-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么用ELK"><a href="#为什么用ELK" class="headerlink" title="为什么用ELK"></a>为什么用ELK</h2><p>当前公司项目部署在十几台服务器上。 通过tail、grep等命令直接去每台服务器查日志很不方便。给开发团队每个成员维护日志查询账号也很麻烦。 希望能有一套集中的日志系统，方便开发人员查询日志，定位问题，也方便运维对异常日志进行监控。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/09/24/elk/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/24/aqs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaoyd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhaoyd's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/24/aqs/" class="post-title-link" itemprop="url">读AQS源码</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-24 20:39:00" itemprop="dateCreated datePublished" datetime="2021-09-24T20:39:00+08:00">2021-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-28 16:49:09" itemprop="dateModified" datetime="2022-06-28T16:49:09+08:00">2022-06-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h2><p>AbstractQueueSynchronizer，是java.util.concurrent中最重要的类，是许多常用的并发工具类的基础，ReentrantLock、CountDownLatch、Semaphore、FutureTask 等都是在AQS抽象类的基础上实现而来。 学习AQS源码有助于更好的理解并发工具类的实现原理，对写出更高效、健壮的代码很有帮助。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/09/24/aqs/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/26/memery_leak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaoyd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhaoyd's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/26/memery_leak/" class="post-title-link" itemprop="url">线上一次堆外内存泄露排查解决</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-26 19:50:13" itemprop="dateCreated datePublished" datetime="2021-05-26T19:50:13+08:00">2021-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-17 23:25:58" itemprop="dateModified" datetime="2021-06-17T23:25:58+08:00">2021-06-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>周六收到服务器告警，线上一台32G服务器的内存占用90%+，远远超出JVM设置的内存-Xmx8192m<br>top命令查看线上进程信息，发现一个java进程占用内存达到26G</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/05/26/memery_leak/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/25/jvm-g1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaoyd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhaoyd's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/25/jvm-g1/" class="post-title-link" itemprop="url">G1垃圾收集器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 14:37:00" itemprop="dateCreated datePublished" datetime="2021-04-25T14:37:00+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-25 11:47:49" itemprop="dateModified" datetime="2021-05-25T11:47:49+08:00">2021-05-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>G1是一款面向服务端应用的垃圾收集器，HotSpot开发团队设计用来取代CMS收集器，特点是追求低并且可控(预测)的停顿时间、在此基础上尽可能提高系统吞吐量。  </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/25/jvm-g1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/23/jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaoyd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhaoyd's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/jvm/" class="post-title-link" itemprop="url">理解JVM概念</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 14:00:00" itemprop="dateCreated datePublished" datetime="2021-04-23T14:00:00+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-25 11:47:49" itemprop="dateModified" datetime="2021-05-25T11:47:49+08:00">2021-05-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>《深入理解JAVA虚拟机》部分概念整理，内存结构、垃圾收集、内存分配。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/23/jvm/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/11/distributed_transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhaoyd">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhaoyd's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/11/distributed_transaction/" class="post-title-link" itemprop="url">四种分布式事务解决方案</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-11 15:40:00" itemprop="dateCreated datePublished" datetime="2021-04-11T15:40:00+08:00">2021-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-25 11:47:49" itemprop="dateModified" datetime="2021-05-25T11:47:49+08:00">2021-05-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="四种事务模式"><a href="#四种事务模式" class="headerlink" title="四种事务模式"></a>四种事务模式</h2><h3 id="AT"><a href="#AT" class="headerlink" title="AT"></a>AT</h3><p>个人理解：一阶段各个分支提交本地事务、如果有任一分支事务一阶段失败，则二阶段各分支回滚数据，否则标记AT事务成功（二阶段成功）。 通过本地数据库事务配合实现，中间要考虑脏读、脏写的问题  </p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/11/distributed_transaction/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhaoyd</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhaoyd</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
